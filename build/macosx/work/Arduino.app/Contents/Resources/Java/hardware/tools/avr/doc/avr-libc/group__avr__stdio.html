<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <title>avr-libc: &lt;stdio.h&gt;: Standard IO facilities</title>
    <link href="dox.css" rel="stylesheet" type="text/css">
  </head>
<body>
<center>
<table width="80%">
  <tr>
    <td align="left"><a href="http://www.nongnu.org/avr-libc/">AVR Libc Home Page</a></td>
    <td align="center" colspan=4><img src="avrs.png" alt="AVRs" align="middle" border="0"></td>
    <td align="right"><a href="https://savannah.nongnu.org/projects/avr-libc/">AVR Libc Development Pages</a></td>
  </tr>
  <tr>
    <td align="center" width="13%"><a href="index.html">Main Page</a></td>
    <td align="center" width="13%"><a href="pages.html">User Manual</a></td>
    <td align="center" width="13%"><a href="modules.html">Library Reference</a></td>
    <td align="center" width="13%"><a href="FAQ.html">FAQ</a></td>
    <td align="center" width="13%"><a href="globals.html">Alphabetical Index</a></td>
    <td align="center" width="13%"><a href="group__demos.html">Example Projects</a></td>
  </tr>
</table>
</center>
<hr width="80%">
<!-- Generated by Doxygen 1.5.7 -->
<div class="contents">
<h1>&lt;stdio.h&gt;: Standard IO facilities</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g3e8cefeee58f762ff50bcef35fa12eec">FILE</a>&nbsp;&nbsp;&nbsp;struct __file</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gaca70138f0cb63ddb026921afc635179">stdin</a>&nbsp;&nbsp;&nbsp;(__iob[0])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g0c0ef221f95f64e8632451312fd18cc8">stdout</a>&nbsp;&nbsp;&nbsp;(__iob[1])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g5ce35bd5ba5021fd3b2e951e8f497656">stderr</a>&nbsp;&nbsp;&nbsp;(__iob[2])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g59adc4c82490d23754cd39c2fb99b0da">EOF</a>&nbsp;&nbsp;&nbsp;(-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g793fcb8f10b6b8746d4186012929ddf1">fdev_set_udata</a>(stream, u)&nbsp;&nbsp;&nbsp;do { (stream)-&gt;udata = u; } while(0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gc04f5faa8e86a4ce4ae084d85386af40">fdev_get_udata</a>(stream)&nbsp;&nbsp;&nbsp;((stream)-&gt;udata)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gf41f158c022cbb6203ccd87d27301226">fdev_setup_stream</a>(stream, put, get, rwflag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g79826a1c733e4f67843256d34ad64352">_FDEV_SETUP_READ</a>&nbsp;&nbsp;&nbsp;__SRD</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g822a791a1c06a12b95c14ace75b48ad2">_FDEV_SETUP_WRITE</a>&nbsp;&nbsp;&nbsp;__SWR</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g93db55caeeaf13488a635f8896a6bdf3">_FDEV_SETUP_RW</a>&nbsp;&nbsp;&nbsp;(__SRD|__SWR)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g132917c782a0ba854c3ae9abe57c3b12">_FDEV_ERR</a>&nbsp;&nbsp;&nbsp;(-1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g280c47b9edff2751b8dbb9a715dc44c5">_FDEV_EOF</a>&nbsp;&nbsp;&nbsp;(-2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gea2b6be92ead4673bc487b271b7227fb">FDEV_SETUP_STREAM</a>(put, get, rwflag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#ga1226b8f734a1b5148d931ae2908c45d">fdev_close</a>()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g247111653f3e91bf2cb4930d590d8201">putc</a>(__c, __stream)&nbsp;&nbsp;&nbsp;fputc(__c, __stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g61e2590ae5f2f2e351365640d2ac755a">putchar</a>(__c)&nbsp;&nbsp;&nbsp;fputc(__c, stdout)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gcff255b3a0079ebb1516e8a4eb23a6fb">getc</a>(__stream)&nbsp;&nbsp;&nbsp;fgetc(__stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gc0484b3e3a4d8361d91c3322440f9195">getchar</a>()&nbsp;&nbsp;&nbsp;fgetc(stdin)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gd3d27a6dcc225237171196dd0739bb10">fclose</a> (FILE *__stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf</a> (FILE *__stream, const char *__fmt, va_list __ap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g55b25ecbfd3811ea4495d1f235e2e186">vfprintf_P</a> (FILE *__stream, const char *__fmt, va_list __ap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gf3387285b3eb0ce4e0e7ca3ccaed9014">fputc</a> (int __c, FILE *__stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g4c04da4953607fa5fa4d3908fecde449">printf</a> (const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g418e63921ed6259e873cd21b6c5c8e6e">printf_P</a> (const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g0b15be24dd9db93355e1f62937fdfd9a">vprintf</a> (const char *__fmt, va_list __ap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g6017094d9fd800fa02600d35399f2a2a">sprintf</a> (char *__s, const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g2b829d696b17dedbf181cd5dc4d7a31d">sprintf_P</a> (char *__s, const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g77070c245d4ca4f7ec7d7144260fb875">snprintf</a> (char *__s, size_t __n, const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g53ff61856759709eeceae10aaa10a0a3">snprintf_P</a> (char *__s, size_t __n, const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gaeb1bbe21a1b9b50b207ab059a67993f">vsprintf</a> (char *__s, const char *__fmt, va_list ap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gf47f5141509d1e434f9da2b27287a707">vsprintf_P</a> (char *__s, const char *__fmt, va_list ap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gc92e8c42a044c8f50aad5c2c69e638e0">vsnprintf</a> (char *__s, size_t __n, const char *__fmt, va_list ap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g2071feb5c92bf50a6bd508a07ead9515">vsnprintf_P</a> (char *__s, size_t __n, const char *__fmt, va_list ap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g0e41285401c397eb29692205a95fcd9c">fprintf</a> (FILE *__stream, const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g36173b4a8551b61811089198beec69d9">fprintf_P</a> (FILE *__stream, const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g19c2bbe9ce4af9f0a7e3448387004fd3">fputs</a> (const char *__str, FILE *__stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g3d25813cb225ca410518a3f48eb00caa">fputs_P</a> (const char *__str, FILE *__stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g33f7bd99d40bf6f68a00d5507d65363d">puts</a> (const char *__str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gb4de83c560c79bf880fa39b997d61610">puts_P</a> (const char *__str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gdd5777719a41713629a62b68c239a774">fwrite</a> (const void *__ptr, size_t __size, size_t __nmemb, FILE *__stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g818d63019adc9d518a13f9c36ed04f35">fgetc</a> (FILE *__stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gb4f9b130166e5811519513d6178c1ae3">ungetc</a> (int __c, FILE *__stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g00d34a8bff0293d2d6f4563d248d8fb2">fgets</a> (char *__str, int __size, FILE *__stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gf577dcba9afe50a9d068d0b69ac85d2f">gets</a> (char *__str)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g54fa47156a34c1659a29ed96e46e3518">fread</a> (void *__ptr, size_t __size, size_t __nmemb, FILE *__stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gaa6d255675688c736c99ebd32f2a7214">clearerr</a> (FILE *__stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g47b00053272d6443c9befdb1304002cb">feof</a> (FILE *__stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#ga89248dd55efb5f59a96e82976c97758">ferror</a> (FILE *__stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g67bae1ad3af79809fd770be392f90e21">vfscanf</a> (FILE *__stream, const char *__fmt, va_list __ap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g6c6b5b881ce8f4739777ff3a615e988a">vfscanf_P</a> (FILE *__stream, const char *__fmt, va_list __ap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g0beb4fd9ff6833a364e3ce60370de058">fscanf</a> (FILE *__stream, const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g7aec94e711ad64724076666586a26839">fscanf_P</a> (FILE *__stream, const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g3f0edc16dcabb5344d59d42cf7682102">scanf</a> (const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g0fb7fd70cd7618f27d8219c97e61bcf3">scanf_P</a> (const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g8bd4b760f67791a54e73111734caa82f">vscanf</a> (const char *__fmt, va_list __ap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#g5507d0e1bbfd387fbb2ffcfd8f5dca6f">sscanf</a> (const char *__buf, const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#geca11dc4b3757ed4ff2f2a4950eba117">sscanf_P</a> (const char *__buf, const char *__fmt,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gdb974f28765a31026ee6bf71d5175951">fflush</a> (FILE *stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen</a> (int(*put)(char, FILE *), int(*get)(FILE *))</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;<a class="code" href="stdio_8h.html">stdio.h</a>&gt;</span> 
</pre></div><p>
<h3>Introduction to the Standard IO facilities</h3>
<p>
This file declares the standard IO facilities that are implemented in <code>avr-libc</code>. Due to the nature of the underlying hardware, only a limited subset of standard IO is implemented. There is no actual file implementation available, so only device IO can be performed. Since there's no operating system, the application needs to provide enough details about their devices in order to make them usable by the standard IO facilities.<p>
Due to space constraints, some functionality has not been implemented at all (like some of the <code>printf</code> conversions that have been left out). Nevertheless, potential users of this implementation should be warned: the <code>printf</code> and <code>scanf</code> families of functions, although usually associated with presumably simple things like the famous "Hello, world!" program, are actually fairly complex which causes their inclusion to eat up a fair amount of code space. Also, they are not fast due to the nature of interpreting the format string at run-time. Whenever possible, resorting to the (sometimes non-standard) predetermined conversion facilities that are offered by avr-libc will usually cost much less in terms of speed and code size.<p>
<h3>Tunable options for code size vs. feature set</h3>
<p>
In order to allow programmers a code size vs. functionality tradeoff, the function <a class="el" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf()</a> which is the heart of the printf family can be selected in different flavours using linker options. See the documentation of <a class="el" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf()</a> for a detailed description. The same applies to <a class="el" href="group__avr__stdio.html#g67bae1ad3af79809fd770be392f90e21">vfscanf()</a> and the <code>scanf</code> family of functions.<p>
<h3>Outline of the chosen API</h3>
<p>
The standard streams <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> are provided, but contrary to the C standard, since avr-libc has no knowledge about applicable devices, these streams are not already pre-initialized at application startup. Also, since there is no notion of "file" whatsoever to avr-libc, there is no function <code>fopen()</code> that could be used to associate a stream to some device. (See <a class="el" href="group__avr__stdio.html#stdio_note1">note 1</a>.) Instead, the function <code><a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a></code> is provided to associate a stream to a device, where the device needs to provide a function to send a character, to receive a character, or both. There is no differentiation between "text" and "binary" streams inside avr-libc. Character <code>\n</code> is sent literally down to the device's <code>put()</code> function. If the device requires a carriage return (<code>\r</code>) character to be sent before the linefeed, its <code>put()</code> routine must implement this (see <a class="el" href="group__avr__stdio.html#stdio_note2">note 2</a>).<p>
As an alternative method to <a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a>, the macro <a class="el" href="group__avr__stdio.html#gf41f158c022cbb6203ccd87d27301226" title="Setup a user-supplied buffer as an stdio stream.">fdev_setup_stream()</a> might be used to setup a user-supplied FILE structure.<p>
It should be noted that the automatic conversion of a newline character into a carriage return - newline sequence breaks binary transfers. If binary transfers are desired, no automatic conversion should be performed, but instead any string that aims to issue a CR-LF sequence must use <code>"\r\n"</code> explicitly.<p>
For convenience, the first call to <code><a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a></code> that opens a stream for reading will cause the resulting stream to be aliased to <code>stdin</code>. Likewise, the first call to <code><a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a></code> that opens a stream for writing will cause the resulting stream to be aliased to both, <code>stdout</code>, and <code>stderr</code>. Thus, if the open was done with both, read and write intent, all three standard streams will be identical. Note that these aliases are indistinguishable from each other, thus calling <code><a class="el" href="group__avr__stdio.html#gd3d27a6dcc225237171196dd0739bb10">fclose()</a></code> on such a stream will also effectively close all of its aliases (<a class="el" href="group__avr__stdio.html#stdio_note3">note 3</a>).<p>
It is possible to tie additional user data to a stream, using <a class="el" href="group__avr__stdio.html#g793fcb8f10b6b8746d4186012929ddf1">fdev_set_udata()</a>. The backend put and get functions can then extract this user data using <a class="el" href="group__avr__stdio.html#gc04f5faa8e86a4ce4ae084d85386af40">fdev_get_udata()</a>, and act appropriately. For example, a single put function could be used to talk to two different UARTs that way, or the put and get functions could keep internal state between calls there.<p>
<h3>Format strings in flash ROM</h3>
<p>
All the <code>printf</code> and <code>scanf</code> family functions come in two flavours: the standard name, where the format string is expected to be in SRAM, as well as a version with the suffix "_P" where the format string is expected to reside in the flash ROM. The macro <code>PSTR</code> (explained in <a class="el" href="group__avr__pgmspace.html">&lt;avr/pgmspace.h&gt;: Program Space Utilities</a>) becomes very handy for declaring these format strings.<p>
<a class="anchor" name="stdio_without_malloc"></a> <h3>Running stdio without <a class="el" href="group__avr__stdlib.html#g4996af830ebe744d9678e5251dfd3ebd">malloc()</a></h3>
<p>
By default, <a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a> requires <a class="el" href="group__avr__stdlib.html#g4996af830ebe744d9678e5251dfd3ebd">malloc()</a>. As this is often not desired in the limited environment of a microcontroller, an alternative option is provided to run completely without <a class="el" href="group__avr__stdlib.html#g4996af830ebe744d9678e5251dfd3ebd">malloc()</a>.<p>
The macro <a class="el" href="group__avr__stdio.html#gf41f158c022cbb6203ccd87d27301226" title="Setup a user-supplied buffer as an stdio stream.">fdev_setup_stream()</a> is provided to prepare a user-supplied FILE buffer for operation with stdio.<p>
<h4>Example</h4>
<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include &lt;<a class="code" href="stdio_8h.html">stdio.h</a>&gt;</span>

    <span class="keyword">static</span> <span class="keywordtype">int</span> uart_putchar(<span class="keywordtype">char</span> c, <a class="code" href="group__avr__stdio.html#g3e8cefeee58f762ff50bcef35fa12eec">FILE</a> *stream);

    <span class="keyword">static</span> <a class="code" href="group__avr__stdio.html#g3e8cefeee58f762ff50bcef35fa12eec">FILE</a> mystdout = <a class="code" href="group__avr__stdio.html#gea2b6be92ead4673bc487b271b7227fb" title="Initializer for a user-supplied stdio stream.">FDEV_SETUP_STREAM</a>(uart_putchar, NULL,
                                             <a class="code" href="group__avr__stdio.html#g822a791a1c06a12b95c14ace75b48ad2">_FDEV_SETUP_WRITE</a>);

    <span class="keyword">static</span> <span class="keywordtype">int</span>
    uart_putchar(<span class="keywordtype">char</span> c, <a class="code" href="group__avr__stdio.html#g3e8cefeee58f762ff50bcef35fa12eec">FILE</a> *stream)
    {

      <span class="keywordflow">if</span> (c == <span class="charliteral">'\n'</span>)
        uart_putchar(<span class="charliteral">'\r'</span>, stream);
      <a class="code" href="group__avr__sfr.html#gaf6857fa882da35f8685e2001e5c3bbe">loop_until_bit_is_set</a>(UCSRA, UDRE);
      UDR = c;
      <span class="keywordflow">return</span> 0;
    }

    <span class="keywordtype">int</span>
    main(<span class="keywordtype">void</span>)
    {
      init_uart();
      <a class="code" href="group__avr__stdio.html#g0c0ef221f95f64e8632451312fd18cc8">stdout</a> = &amp;mystdout;
      <a class="code" href="group__avr__stdio.html#g4c04da4953607fa5fa4d3908fecde449">printf</a>(<span class="stringliteral">"Hello, world!\n"</span>);

      <span class="keywordflow">return</span> 0;
    }
</pre></div><p>
This example uses the initializer form <a class="el" href="group__avr__stdio.html#gea2b6be92ead4673bc487b271b7227fb" title="Initializer for a user-supplied stdio stream.">FDEV_SETUP_STREAM()</a> rather than the function-like <a class="el" href="group__avr__stdio.html#gf41f158c022cbb6203ccd87d27301226" title="Setup a user-supplied buffer as an stdio stream.">fdev_setup_stream()</a>, so all data initialization happens during C start-up.<p>
If streams initialized that way are no longer needed, they can be destroyed by first calling the macro <a class="el" href="group__avr__stdio.html#ga1226b8f734a1b5148d931ae2908c45d">fdev_close()</a>, and then destroying the object itself. No call to <a class="el" href="group__avr__stdio.html#gd3d27a6dcc225237171196dd0739bb10">fclose()</a> should be issued for these streams. While calling <a class="el" href="group__avr__stdio.html#gd3d27a6dcc225237171196dd0739bb10">fclose()</a> itself is harmless, it will cause an undefined reference to <a class="el" href="group__avr__stdlib.html#gfb8699abb1f51d920a176e695ff3be8a">free()</a> and thus cause the linker to link the malloc module into the application.<p>
<h3>Notes</h3>
<p>
<a class="anchor" name="stdio_note1"></a> <dl class="user" compact><dt><b>Note 1:</b></dt><dd>It might have been possible to implement a device abstraction that is compatible with <code>fopen()</code> but since this would have required to parse a string, and to take all the information needed either out of this string, or out of an additional table that would need to be provided by the application, this approach was not taken.</dd></dl>
<a class="anchor" name="stdio_note2"></a> <dl class="user" compact><dt><b>Note 2:</b></dt><dd>This basically follows the Unix approach: if a device such as a terminal needs special handling, it is in the domain of the terminal device driver to provide this functionality. Thus, a simple function suitable as <code>put()</code> for <code><a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a></code> that talks to a UART interface might look like this:</dd></dl>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span>
    uart_putchar(<span class="keywordtype">char</span> c, <a class="code" href="group__avr__stdio.html#g3e8cefeee58f762ff50bcef35fa12eec">FILE</a> *stream)
    {

      <span class="keywordflow">if</span> (c == <span class="charliteral">'\n'</span>)
        uart_putchar(<span class="charliteral">'\r'</span>);
      <a class="code" href="group__avr__sfr.html#gaf6857fa882da35f8685e2001e5c3bbe">loop_until_bit_is_set</a>(UCSRA, UDRE);
      UDR = c;
      <span class="keywordflow">return</span> 0;
    }
</pre></div><p>
<a class="anchor" name="stdio_note3"></a> <dl class="user" compact><dt><b>Note 3:</b></dt><dd>This implementation has been chosen because the cost of maintaining an alias is considerably smaller than the cost of maintaining full copies of each stream. Yet, providing an implementation that offers the complete set of standard streams was deemed to be useful. Not only that writing <code><a class="el" href="group__avr__stdio.html#g4c04da4953607fa5fa4d3908fecde449">printf()</a></code> instead of <code>fprintf(mystream, ...)</code> saves typing work, but since avr-gcc needs to resort to pass all arguments of variadic functions on the stack (as opposed to passing them in registers for functions that take a fixed number of parameters), the ability to pass one parameter less by implying <code>stdin</code> will also save some execution time. </dd></dl>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g280c47b9edff2751b8dbb9a715dc44c5"></a><!-- doxytag: member="stdio.h::_FDEV_EOF" ref="g280c47b9edff2751b8dbb9a715dc44c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _FDEV_EOF&nbsp;&nbsp;&nbsp;(-2)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return code for an end-of-file condition during device read.<p>
To be used in the get function of <a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a>. 
</div>
</div><p>
<a class="anchor" name="g132917c782a0ba854c3ae9abe57c3b12"></a><!-- doxytag: member="stdio.h::_FDEV_ERR" ref="g132917c782a0ba854c3ae9abe57c3b12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _FDEV_ERR&nbsp;&nbsp;&nbsp;(-1)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return code for an error condition during device read.<p>
To be used in the get function of <a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a>. 
</div>
</div><p>
<a class="anchor" name="g79826a1c733e4f67843256d34ad64352"></a><!-- doxytag: member="stdio.h::_FDEV_SETUP_READ" ref="g79826a1c733e4f67843256d34ad64352" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _FDEV_SETUP_READ&nbsp;&nbsp;&nbsp;__SRD          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="group__avr__stdio.html#gf41f158c022cbb6203ccd87d27301226" title="Setup a user-supplied buffer as an stdio stream.">fdev_setup_stream()</a> with read intent 
</div>
</div><p>
<a class="anchor" name="g93db55caeeaf13488a635f8896a6bdf3"></a><!-- doxytag: member="stdio.h::_FDEV_SETUP_RW" ref="g93db55caeeaf13488a635f8896a6bdf3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _FDEV_SETUP_RW&nbsp;&nbsp;&nbsp;(__SRD|__SWR)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="group__avr__stdio.html#gf41f158c022cbb6203ccd87d27301226" title="Setup a user-supplied buffer as an stdio stream.">fdev_setup_stream()</a> with read/write intent 
</div>
</div><p>
<a class="anchor" name="g822a791a1c06a12b95c14ace75b48ad2"></a><!-- doxytag: member="stdio.h::_FDEV_SETUP_WRITE" ref="g822a791a1c06a12b95c14ace75b48ad2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _FDEV_SETUP_WRITE&nbsp;&nbsp;&nbsp;__SWR          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="group__avr__stdio.html#gf41f158c022cbb6203ccd87d27301226" title="Setup a user-supplied buffer as an stdio stream.">fdev_setup_stream()</a> with write intent 
</div>
</div><p>
<a class="anchor" name="g59adc4c82490d23754cd39c2fb99b0da"></a><!-- doxytag: member="stdio.h::EOF" ref="g59adc4c82490d23754cd39c2fb99b0da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EOF&nbsp;&nbsp;&nbsp;(-1)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>EOF</code> declares the value that is returned by various standard IO functions in case of an error. Since the AVR platform (currently) doesn't contain an abstraction for actual files, its origin as "end of file" is somewhat meaningless here. 
</div>
</div><p>
<a class="anchor" name="ga1226b8f734a1b5148d931ae2908c45d"></a><!-- doxytag: member="stdio.h::fdev_close" ref="ga1226b8f734a1b5148d931ae2908c45d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fdev_close          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This macro frees up any library resources that might be associated with <code>stream</code>. It should be called if <code>stream</code> is no longer needed, right before the application is going to destroy the <code>stream</code> object itself.<p>
(Currently, this macro evaluates to nothing, but this might change in future versions of the library.) 
</div>
</div><p>
<a class="anchor" name="gc04f5faa8e86a4ce4ae084d85386af40"></a><!-- doxytag: member="stdio.h::fdev_get_udata" ref="gc04f5faa8e86a4ce4ae084d85386af40" args="(stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fdev_get_udata          </td>
          <td>(</td>
          <td class="paramtype">stream&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((stream)-&gt;udata)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This macro retrieves a pointer to user defined data from a FILE stream object. 
</div>
</div><p>
<a class="anchor" name="g793fcb8f10b6b8746d4186012929ddf1"></a><!-- doxytag: member="stdio.h::fdev_set_udata" ref="g793fcb8f10b6b8746d4186012929ddf1" args="(stream, u)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fdev_set_udata          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;do { (stream)-&gt;udata = u; } while(0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This macro inserts a pointer to user defined data into a FILE stream object.<p>
The user data can be useful for tracking state in the put and get functions supplied to the <a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a> function. 
</div>
</div><p>
<a class="anchor" name="gea2b6be92ead4673bc487b271b7227fb"></a><!-- doxytag: member="stdio.h::FDEV_SETUP_STREAM" ref="gea2b6be92ead4673bc487b271b7227fb" args="(put, get, rwflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FDEV_SETUP_STREAM          </td>
          <td>(</td>
          <td class="paramtype">put,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">get,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rwflag&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializer for a user-supplied stdio stream. 
<p>
This macro acts similar to <a class="el" href="group__avr__stdio.html#gf41f158c022cbb6203ccd87d27301226" title="Setup a user-supplied buffer as an stdio stream.">fdev_setup_stream()</a>, but it is to be used as the initializer of a variable of type FILE.<p>
The remaining arguments are to be used as explained in <a class="el" href="group__avr__stdio.html#gf41f158c022cbb6203ccd87d27301226" title="Setup a user-supplied buffer as an stdio stream.">fdev_setup_stream()</a>. 
</div>
</div><p>
<a class="anchor" name="gf41f158c022cbb6203ccd87d27301226"></a><!-- doxytag: member="stdio.h::fdev_setup_stream" ref="gf41f158c022cbb6203ccd87d27301226" args="(stream, put, get, rwflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fdev_setup_stream          </td>
          <td>(</td>
          <td class="paramtype">stream,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">put,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">get,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rwflag&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Setup a user-supplied buffer as an stdio stream. 
<p>
This macro takes a user-supplied buffer <code>stream</code>, and sets it up as a stream that is valid for stdio operations, similar to one that has been obtained dynamically from <a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a>. The buffer to setup must be of type FILE.<p>
The arguments <code>put</code> and <code>get</code> are identical to those that need to be passed to <a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a>.<p>
The <code>rwflag</code> argument can take one of the values _FDEV_SETUP_READ, _FDEV_SETUP_WRITE, or _FDEV_SETUP_RW, for read, write, or read/write intent, respectively.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>No assignments to the standard streams will be performed by <a class="el" href="group__avr__stdio.html#gf41f158c022cbb6203ccd87d27301226" title="Setup a user-supplied buffer as an stdio stream.">fdev_setup_stream()</a>. If standard streams are to be used, these need to be assigned by the user. See also under <a class="el" href="group__avr__stdio.html#stdio_without_malloc">Running stdio without malloc()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3e8cefeee58f762ff50bcef35fa12eec"></a><!-- doxytag: member="stdio.h::FILE" ref="g3e8cefeee58f762ff50bcef35fa12eec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FILE&nbsp;&nbsp;&nbsp;struct __file          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>FILE</code> is the opaque structure that is passed around between the various standard IO functions. 
</div>
</div><p>
<a class="anchor" name="gcff255b3a0079ebb1516e8a4eb23a6fb"></a><!-- doxytag: member="stdio.h::getc" ref="gcff255b3a0079ebb1516e8a4eb23a6fb" args="(__stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define getc          </td>
          <td>(</td>
          <td class="paramtype">__stream&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;fgetc(__stream)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The macro <code>getc</code> used to be a "fast" macro implementation with a functionality identical to <a class="el" href="group__avr__stdio.html#g818d63019adc9d518a13f9c36ed04f35">fgetc()</a>. For space constraints, in <code>avr-libc</code>, it is just an alias for <code>fgetc</code>. 
</div>
</div><p>
<a class="anchor" name="gc0484b3e3a4d8361d91c3322440f9195"></a><!-- doxytag: member="stdio.h::getchar" ref="gc0484b3e3a4d8361d91c3322440f9195" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define getchar          </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;fgetc(stdin)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The macro <code>getchar</code> reads a character from <code>stdin</code>. Return values and error handling is identical to <a class="el" href="group__avr__stdio.html#g818d63019adc9d518a13f9c36ed04f35">fgetc()</a>. 
</div>
</div><p>
<a class="anchor" name="g247111653f3e91bf2cb4930d590d8201"></a><!-- doxytag: member="stdio.h::putc" ref="g247111653f3e91bf2cb4930d590d8201" args="(__c, __stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define putc          </td>
          <td>(</td>
          <td class="paramtype">__c,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__stream&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;fputc(__c, __stream)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The macro <code>putc</code> used to be a "fast" macro implementation with a functionality identical to <a class="el" href="group__avr__stdio.html#gf3387285b3eb0ce4e0e7ca3ccaed9014">fputc()</a>. For space constraints, in <code>avr-libc</code>, it is just an alias for <code>fputc</code>. 
</div>
</div><p>
<a class="anchor" name="g61e2590ae5f2f2e351365640d2ac755a"></a><!-- doxytag: member="stdio.h::putchar" ref="g61e2590ae5f2f2e351365640d2ac755a" args="(__c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define putchar          </td>
          <td>(</td>
          <td class="paramtype">__c&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;fputc(__c, stdout)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The macro <code>putchar</code> sends character <code>c</code> to <code>stdout</code>. 
</div>
</div><p>
<a class="anchor" name="g5ce35bd5ba5021fd3b2e951e8f497656"></a><!-- doxytag: member="stdio.h::stderr" ref="g5ce35bd5ba5021fd3b2e951e8f497656" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define stderr&nbsp;&nbsp;&nbsp;(__iob[2])          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stream destined for error output. Unless specifically assigned, identical to <code>stdout</code>.<p>
If <code>stderr</code> should point to another stream, the result of another <code><a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a></code> must be explicitly assigned to it without closing the previous <code>stderr</code> (since this would also close <code>stdout</code>). 
</div>
</div><p>
<a class="anchor" name="gaca70138f0cb63ddb026921afc635179"></a><!-- doxytag: member="stdio.h::stdin" ref="gaca70138f0cb63ddb026921afc635179" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define stdin&nbsp;&nbsp;&nbsp;(__iob[0])          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stream that will be used as an input stream by the simplified functions that don't take a <code>stream</code> argument.<p>
The first stream opened with read intent using <code><a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a></code> will be assigned to <code>stdin</code>. 
</div>
</div><p>
<a class="anchor" name="g0c0ef221f95f64e8632451312fd18cc8"></a><!-- doxytag: member="stdio.h::stdout" ref="g0c0ef221f95f64e8632451312fd18cc8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define stdout&nbsp;&nbsp;&nbsp;(__iob[1])          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stream that will be used as an output stream by the simplified functions that don't take a <code>stream</code> argument.<p>
The first stream opened with write intent using <code><a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a></code> will be assigned to both, <code>stdin</code>, and <code>stderr</code>. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gaa6d255675688c736c99ebd32f2a7214"></a><!-- doxytag: member="stdio.h::clearerr" ref="gaa6d255675688c736c99ebd32f2a7214" args="(FILE *__stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clearerr           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the error and end-of-file flags of <code>stream</code>. 
</div>
</div><p>
<a class="anchor" name="gd3d27a6dcc225237171196dd0739bb10"></a><!-- doxytag: member="stdio.h::fclose" ref="gd3d27a6dcc225237171196dd0739bb10" args="(FILE *__stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fclose           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function closes <code>stream</code>, and disallows and further IO to and from it.<p>
When using <a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a> to setup the stream, a call to <a class="el" href="group__avr__stdio.html#gd3d27a6dcc225237171196dd0739bb10">fclose()</a> is needed in order to free the internal resources allocated.<p>
If the stream has been set up using <a class="el" href="group__avr__stdio.html#gf41f158c022cbb6203ccd87d27301226" title="Setup a user-supplied buffer as an stdio stream.">fdev_setup_stream()</a> or <a class="el" href="group__avr__stdio.html#gea2b6be92ead4673bc487b271b7227fb" title="Initializer for a user-supplied stdio stream.">FDEV_SETUP_STREAM()</a>, use <a class="el" href="group__avr__stdio.html#ga1226b8f734a1b5148d931ae2908c45d">fdev_close()</a> instead.<p>
It currently always returns 0 (for success). 
</div>
</div><p>
<a class="anchor" name="gb599ddf60819df4cc993c724a83cb1a4"></a><!-- doxytag: member="fdevopen.c::fdevopen" ref="gb599ddf60819df4cc993c724a83cb1a4" args="(int(*put)(char, FILE *), int(*get)(FILE *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* fdevopen           </td>
          <td>(</td>
          <td class="paramtype">int(*)(char, FILE *)&nbsp;</td>
          <td class="paramname"> <em>put</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(FILE *)&nbsp;</td>
          <td class="paramname"> <em>get</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is a replacement for <code>fopen()</code>.<p>
It opens a stream for a device where the actual device implementation needs to be provided by the application. If successful, a pointer to the structure for the opened stream is returned. Reasons for a possible failure currently include that neither the <code>put</code> nor the <code>get</code> argument have been provided, thus attempting to open a stream with no IO intent at all, or that insufficient dynamic memory is available to establish a new stream.<p>
If the <code>put</code> function pointer is provided, the stream is opened with write intent. The function passed as <code>put</code> shall take two arguments, the first a character to write to the device, and the second a pointer to FILE, and shall return 0 if the output was successful, and a nonzero value if the character could not be sent to the device.<p>
If the <code>get</code> function pointer is provided, the stream is opened with read intent. The function passed as <code>get</code> shall take a pointer to FILE as its single argument, and return one character from the device, passed as an <code>int</code> type. If an error occurs when trying to read from the device, it shall return <code>_FDEV_ERR</code>. If an end-of-file condition was reached while reading from the device, <code>_FDEV_EOF</code> shall be returned.<p>
If both functions are provided, the stream is opened with read and write intent.<p>
The first stream opened with read intent is assigned to <code>stdin</code>, and the first one opened with write intent is assigned to both, <code>stdout</code> and <code>stderr</code>.<p>
<a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a> uses <a class="el" href="group__avr__stdlib.html#g51ac965dacbc9daf922f469bdcfe00c2">calloc()</a> (und thus <a class="el" href="group__avr__stdlib.html#g4996af830ebe744d9678e5251dfd3ebd">malloc()</a>) in order to allocate the storage for the new stream.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the macro __STDIO_FDEVOPEN_COMPAT_12 is declared before including &lt;<a class="el" href="stdio_8h.html">stdio.h</a>&gt;, a function prototype for <a class="el" href="group__avr__stdio.html#gb599ddf60819df4cc993c724a83cb1a4">fdevopen()</a> will be chosen that is backwards compatible with avr-libc version 1.2 and before. This is solely intented for providing a simple migration path without the need to immediately change all source code. Do not use for new code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g47b00053272d6443c9befdb1304002cb"></a><!-- doxytag: member="stdio.h::feof" ref="g47b00053272d6443c9befdb1304002cb" args="(FILE *__stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int feof           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test the end-of-file flag of <code>stream</code>. This flag can only be cleared by a call to <a class="el" href="group__avr__stdio.html#gaa6d255675688c736c99ebd32f2a7214">clearerr()</a>. 
</div>
</div><p>
<a class="anchor" name="ga89248dd55efb5f59a96e82976c97758"></a><!-- doxytag: member="stdio.h::ferror" ref="ga89248dd55efb5f59a96e82976c97758" args="(FILE *__stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ferror           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test the error flag of <code>stream</code>. This flag can only be cleared by a call to <a class="el" href="group__avr__stdio.html#gaa6d255675688c736c99ebd32f2a7214">clearerr()</a>. 
</div>
</div><p>
<a class="anchor" name="gdb974f28765a31026ee6bf71d5175951"></a><!-- doxytag: member="stdio.h::fflush" ref="gdb974f28765a31026ee6bf71d5175951" args="(FILE *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fflush           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush <code>stream</code>.<p>
This is a null operation provided for source-code compatibility only, as the standard IO implementation currently does not perform any buffering. 
</div>
</div><p>
<a class="anchor" name="g818d63019adc9d518a13f9c36ed04f35"></a><!-- doxytag: member="stdio.h::fgetc" ref="g818d63019adc9d518a13f9c36ed04f35" args="(FILE *__stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fgetc           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function <code>fgetc</code> reads a character from <code>stream</code>. It returns the character, or <code>EOF</code> in case end-of-file was encountered or an error occurred. The routines <a class="el" href="group__avr__stdio.html#g47b00053272d6443c9befdb1304002cb">feof()</a> or <a class="el" href="group__avr__stdio.html#ga89248dd55efb5f59a96e82976c97758">ferror()</a> must be used to distinguish between both situations. 
</div>
</div><p>
<a class="anchor" name="g00d34a8bff0293d2d6f4563d248d8fb2"></a><!-- doxytag: member="stdio.h::fgets" ref="g00d34a8bff0293d2d6f4563d248d8fb2" args="(char *__str, int __size, FILE *__stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* fgets           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>__str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>__size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read at most <code>size - 1</code> bytes from <code>stream</code>, until a newline character was encountered, and store the characters in the buffer pointed to by <code>str</code>. Unless an error was encountered while reading, the string will then be terminated with a <code>NUL</code> character.<p>
If an error was encountered, the function returns NULL and sets the error flag of <code>stream</code>, which can be tested using <a class="el" href="group__avr__stdio.html#ga89248dd55efb5f59a96e82976c97758">ferror()</a>. Otherwise, a pointer to the string will be returned. 
</div>
</div><p>
<a class="anchor" name="g0e41285401c397eb29692205a95fcd9c"></a><!-- doxytag: member="stdio.h::fprintf" ref="g0e41285401c397eb29692205a95fcd9c" args="(FILE *__stream, const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fprintf           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function <code>fprintf</code> performs formatted output to <code>stream</code>. See <code><a class="el" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf()</a></code> for details. 
</div>
</div><p>
<a class="anchor" name="g36173b4a8551b61811089198beec69d9"></a><!-- doxytag: member="stdio.h::fprintf_P" ref="g36173b4a8551b61811089198beec69d9" args="(FILE *__stream, const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fprintf_P           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <code><a class="el" href="group__avr__stdio.html#g0e41285401c397eb29692205a95fcd9c">fprintf()</a></code> that uses a <code>fmt</code> string that resides in program memory. 
</div>
</div><p>
<a class="anchor" name="gf3387285b3eb0ce4e0e7ca3ccaed9014"></a><!-- doxytag: member="stdio.h::fputc" ref="gf3387285b3eb0ce4e0e7ca3ccaed9014" args="(int __c, FILE *__stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fputc           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>__c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function <code>fputc</code> sends the character <code>c</code> (though given as type <code>int</code>) to <code>stream</code>. It returns the character, or <code>EOF</code> in case an error occurred. 
</div>
</div><p>
<a class="anchor" name="g19c2bbe9ce4af9f0a7e3448387004fd3"></a><!-- doxytag: member="stdio.h::fputs" ref="g19c2bbe9ce4af9f0a7e3448387004fd3" args="(const char *__str, FILE *__stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fputs           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write the string pointed to by <code>str</code> to stream <code>stream</code>.<p>
Returns 0 on success and EOF on error. 
</div>
</div><p>
<a class="anchor" name="g3d25813cb225ca410518a3f48eb00caa"></a><!-- doxytag: member="stdio.h::fputs_P" ref="g3d25813cb225ca410518a3f48eb00caa" args="(const char *__str, FILE *__stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fputs_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <a class="el" href="group__avr__stdio.html#g19c2bbe9ce4af9f0a7e3448387004fd3">fputs()</a> where <code>str</code> resides in program memory. 
</div>
</div><p>
<a class="anchor" name="g54fa47156a34c1659a29ed96e46e3518"></a><!-- doxytag: member="stdio.h::fread" ref="g54fa47156a34c1659a29ed96e46e3518" args="(void *__ptr, size_t __size, size_t __nmemb, FILE *__stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fread           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>__ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>__size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>__nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read <code>nmemb</code> objects, <code>size</code> bytes each, from <code>stream</code>, to the buffer pointed to by <code>ptr</code>.<p>
Returns the number of objects successfully read, i. e. <code>nmemb</code> unless an input error occured or end-of-file was encountered. <a class="el" href="group__avr__stdio.html#g47b00053272d6443c9befdb1304002cb">feof()</a> and <a class="el" href="group__avr__stdio.html#ga89248dd55efb5f59a96e82976c97758">ferror()</a> must be used to distinguish between these two conditions. 
</div>
</div><p>
<a class="anchor" name="g0beb4fd9ff6833a364e3ce60370de058"></a><!-- doxytag: member="stdio.h::fscanf" ref="g0beb4fd9ff6833a364e3ce60370de058" args="(FILE *__stream, const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fscanf           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function <code>fscanf</code> performs formatted input, reading the input data from <code>stream</code>.<p>
See <a class="el" href="group__avr__stdio.html#g67bae1ad3af79809fd770be392f90e21">vfscanf()</a> for details. 
</div>
</div><p>
<a class="anchor" name="g7aec94e711ad64724076666586a26839"></a><!-- doxytag: member="stdio.h::fscanf_P" ref="g7aec94e711ad64724076666586a26839" args="(FILE *__stream, const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fscanf_P           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <a class="el" href="group__avr__stdio.html#g0beb4fd9ff6833a364e3ce60370de058">fscanf()</a> using a <code>fmt</code> string in program memory. 
</div>
</div><p>
<a class="anchor" name="gdd5777719a41713629a62b68c239a774"></a><!-- doxytag: member="stdio.h::fwrite" ref="gdd5777719a41713629a62b68c239a774" args="(const void *__ptr, size_t __size, size_t __nmemb, FILE *__stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fwrite           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>__ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>__size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>__nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write <code>nmemb</code> objects, <code>size</code> bytes each, to <code>stream</code>. The first byte of the first object is referenced by <code>ptr</code>.<p>
Returns the number of objects successfully written, i. e. <code>nmemb</code> unless an output error occured. 
</div>
</div><p>
<a class="anchor" name="gf577dcba9afe50a9d068d0b69ac85d2f"></a><!-- doxytag: member="stdio.h::gets" ref="gf577dcba9afe50a9d068d0b69ac85d2f" args="(char *__str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* gets           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>__str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to <a class="el" href="group__avr__stdio.html#g00d34a8bff0293d2d6f4563d248d8fb2">fgets()</a> except that it will operate on stream <code>stdin</code>, and the trailing newline (if any) will not be stored in the string. It is the caller's responsibility to provide enough storage to hold the characters read. 
</div>
</div><p>
<a class="anchor" name="g4c04da4953607fa5fa4d3908fecde449"></a><!-- doxytag: member="stdio.h::printf" ref="g4c04da4953607fa5fa4d3908fecde449" args="(const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int printf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function <code>printf</code> performs formatted output to stream <code>stderr</code>. See <code><a class="el" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf()</a></code> for details. 
</div>
</div><p>
<a class="anchor" name="g418e63921ed6259e873cd21b6c5c8e6e"></a><!-- doxytag: member="stdio.h::printf_P" ref="g418e63921ed6259e873cd21b6c5c8e6e" args="(const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int printf_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <code><a class="el" href="group__avr__stdio.html#g4c04da4953607fa5fa4d3908fecde449">printf()</a></code> that uses a <code>fmt</code> string that resides in program memory. 
</div>
</div><p>
<a class="anchor" name="g33f7bd99d40bf6f68a00d5507d65363d"></a><!-- doxytag: member="stdio.h::puts" ref="g33f7bd99d40bf6f68a00d5507d65363d" args="(const char *__str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int puts           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write the string pointed to by <code>str</code>, and a trailing newline character, to <code>stdout</code>. 
</div>
</div><p>
<a class="anchor" name="gb4de83c560c79bf880fa39b997d61610"></a><!-- doxytag: member="stdio.h::puts_P" ref="gb4de83c560c79bf880fa39b997d61610" args="(const char *__str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int puts_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <a class="el" href="group__avr__stdio.html#g33f7bd99d40bf6f68a00d5507d65363d">puts()</a> where <code>str</code> resides in program memory. 
</div>
</div><p>
<a class="anchor" name="g3f0edc16dcabb5344d59d42cf7682102"></a><!-- doxytag: member="stdio.h::scanf" ref="g3f0edc16dcabb5344d59d42cf7682102" args="(const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int scanf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function <code>scanf</code> performs formatted input from stream <code>stdin</code>.<p>
See <a class="el" href="group__avr__stdio.html#g67bae1ad3af79809fd770be392f90e21">vfscanf()</a> for details. 
</div>
</div><p>
<a class="anchor" name="g0fb7fd70cd7618f27d8219c97e61bcf3"></a><!-- doxytag: member="stdio.h::scanf_P" ref="g0fb7fd70cd7618f27d8219c97e61bcf3" args="(const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int scanf_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <a class="el" href="group__avr__stdio.html#g3f0edc16dcabb5344d59d42cf7682102">scanf()</a> where <code>fmt</code> resides in program memory. 
</div>
</div><p>
<a class="anchor" name="g77070c245d4ca4f7ec7d7144260fb875"></a><!-- doxytag: member="stdio.h::snprintf" ref="g77070c245d4ca4f7ec7d7144260fb875" args="(char *__s, size_t __n, const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snprintf           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>__s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <code><a class="el" href="group__avr__stdio.html#g6017094d9fd800fa02600d35399f2a2a">sprintf()</a></code>, but instead of assuming <code>s</code> to be of infinite size, no more than <code>n</code> characters (including the trailing NUL character) will be converted to <code>s</code>.<p>
Returns the number of characters that would have been written to <code>s</code> if there were enough space. 
</div>
</div><p>
<a class="anchor" name="g53ff61856759709eeceae10aaa10a0a3"></a><!-- doxytag: member="stdio.h::snprintf_P" ref="g53ff61856759709eeceae10aaa10a0a3" args="(char *__s, size_t __n, const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snprintf_P           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>__s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <code><a class="el" href="group__avr__stdio.html#g77070c245d4ca4f7ec7d7144260fb875">snprintf()</a></code> that uses a <code>fmt</code> string that resides in program memory. 
</div>
</div><p>
<a class="anchor" name="g6017094d9fd800fa02600d35399f2a2a"></a><!-- doxytag: member="stdio.h::sprintf" ref="g6017094d9fd800fa02600d35399f2a2a" args="(char *__s, const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sprintf           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>__s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <code><a class="el" href="group__avr__stdio.html#g4c04da4953607fa5fa4d3908fecde449">printf()</a></code> that sends the formatted characters to string <code>s</code>. 
</div>
</div><p>
<a class="anchor" name="g2b829d696b17dedbf181cd5dc4d7a31d"></a><!-- doxytag: member="stdio.h::sprintf_P" ref="g2b829d696b17dedbf181cd5dc4d7a31d" args="(char *__s, const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sprintf_P           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>__s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <code><a class="el" href="group__avr__stdio.html#g6017094d9fd800fa02600d35399f2a2a">sprintf()</a></code> that uses a <code>fmt</code> string that resides in program memory. 
</div>
</div><p>
<a class="anchor" name="g5507d0e1bbfd387fbb2ffcfd8f5dca6f"></a><!-- doxytag: member="stdio.h::sscanf" ref="g5507d0e1bbfd387fbb2ffcfd8f5dca6f" args="(const char *__buf, const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sscanf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function <code>sscanf</code> performs formatted input, reading the input data from the buffer pointed to by <code>buf</code>.<p>
See <a class="el" href="group__avr__stdio.html#g67bae1ad3af79809fd770be392f90e21">vfscanf()</a> for details. 
</div>
</div><p>
<a class="anchor" name="geca11dc4b3757ed4ff2f2a4950eba117"></a><!-- doxytag: member="stdio.h::sscanf_P" ref="geca11dc4b3757ed4ff2f2a4950eba117" args="(const char *__buf, const char *__fmt,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sscanf_P           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <a class="el" href="group__avr__stdio.html#g5507d0e1bbfd387fbb2ffcfd8f5dca6f">sscanf()</a> using a <code>fmt</code> string in program memory. 
</div>
</div><p>
<a class="anchor" name="gb4f9b130166e5811519513d6178c1ae3"></a><!-- doxytag: member="stdio.h::ungetc" ref="gb4f9b130166e5811519513d6178c1ae3" args="(int __c, FILE *__stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ungetc           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>__c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The <a class="el" href="group__avr__stdio.html#gb4f9b130166e5811519513d6178c1ae3">ungetc()</a> function pushes the character <code>c</code> (converted to an unsigned char) back onto the input stream pointed to by <code>stream</code>. The pushed-back character will be returned by a subsequent read on the stream.<p>
Currently, only a single character can be pushed back onto the stream.<p>
The <a class="el" href="group__avr__stdio.html#gb4f9b130166e5811519513d6178c1ae3">ungetc()</a> function returns the character pushed back after the conversion, or <code>EOF</code> if the operation fails. If the value of the argument <code>c</code> character equals <code>EOF</code>, the operation will fail and the stream will remain unchanged. 
</div>
</div><p>
<a class="anchor" name="ga3b98c0d17b35642c0f3e4649092b9f1"></a><!-- doxytag: member="stdio.h::vfprintf" ref="ga3b98c0d17b35642c0f3e4649092b9f1" args="(FILE *__stream, const char *__fmt, va_list __ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfprintf           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>__ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>vfprintf</code> is the central facility of the <code>printf</code> family of functions. It outputs values to <code>stream</code> under control of a format string passed in <code>fmt</code>. The actual values to print are passed as a variable argument list <code>ap</code>.<p>
<code>vfprintf</code> returns the number of characters written to <code>stream</code>, or <code>EOF</code> in case of an error. Currently, this will only happen if <code>stream</code> has not been opened with write intent.<p>
The format string is composed of zero or more directives: ordinary characters (not <code>%</code>), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments. Each conversion specification is introduced by the <code>%</code> character. The arguments must properly correspond (after type promotion) with the conversion specifier. After the <code>%</code>, the following appear in sequence:<p>
<ul>
<li>Zero or more of the following flags: <ul>
<li>
<code>#</code> The value should be converted to an "alternate form". For c, d, i, s, and u conversions, this option has no effect. For o conversions, the precision of the number is increased to force the first character of the output string to a zero (except if a zero value is printed with an explicit precision of zero). For x and X conversions, a non-zero result has the string `0x' (or `0X' for X conversions) prepended to it. </li>
<li>
<code>0</code> (zero) Zero padding. For all conversions, the converted value is padded on the left with zeros rather than blanks. If a precision is given with a numeric conversion (d, i, o, u, i, x, and X), the 0 flag is ignored. </li>
<li>
<code>-</code> A negative field width flag; the converted value is to be left adjusted on the field boundary. The converted value is padded on the right with blanks, rather than on the left with blanks or zeros. A - overrides a 0 if both are given. </li>
<li>
' ' (space) A blank should be left before a positive number produced by a signed conversion (d, or i). </li>
<li>
<code>+</code> A sign must always be placed before a number produced by a signed conversion. A + overrides a space if both are used. </li>
</ul>
</li></ul>
<p>
<ul>
<li>An optional decimal digit string specifying a minimum field width. If the converted value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the left-adjustment flag has been given) to fill out the field width.</li><li>An optional precision, in the form of a period . followed by an optional digit string. If the digit string is omitted, the precision is taken as zero. This gives the minimum number of digits to appear for d, i, o, u, x, and X conversions, or the maximum number of characters to be printed from a string for <code>s</code> conversions.</li><li>An optional <code>l</code> or <code>h</code> length modifier, that specifies that the argument for the d, i, o, u, x, or X conversion is a <code>"long int"</code> rather than <code>int</code>. The <code>h</code> is ignored, as <code>"short int"</code> is equivalent to <code>int</code>.</li><li>A character that specifies the type of conversion to be applied.</li></ul>
<p>
The conversion specifiers and their meanings are:<p>
<ul>
<li><code>diouxX</code> The int (or appropriate variant) argument is converted to signed decimal (d and i), unsigned octal (o), unsigned decimal (u), or unsigned hexadecimal (x and X) notation. The letters "abcdef" are used for x conversions; the letters "ABCDEF" are used for X conversions. The precision, if any, gives the minimum number of digits that must appear; if the converted value requires fewer digits, it is padded on the left with zeros.</li><li><code>p</code> The <code>void *</code> argument is taken as an unsigned integer, and converted similarly as a <code>%#x</code> command would do.</li><li><code>c</code> The <code>int</code> argument is converted to an <code>"unsigned char"</code>, and the resulting character is written.</li><li><code>s</code> The <code>"char *"</code> argument is expected to be a pointer to an array of character type (pointer to a string). Characters from the array are written up to (but not including) a terminating NUL character; if a precision is specified, no more than the number specified are written. If a precision is given, no null character need be present; if the precision is not specified, or is greater than the size of the array, the array must contain a terminating NUL character.</li><li><code>%</code> A <code>%</code> is written. No argument is converted. The complete conversion specification is "%%".</li><li><code>eE</code> The double argument is rounded and converted in the format <code>"[-]d.dddedd"</code> where there is one digit before the decimal-point character and the number of digits after it is equal to the precision; if the precision is missing, it is taken as 6; if the precision is zero, no decimal-point character appears. An <em>E</em> conversion uses the letter <code>'E'</code> (rather than <code>'e'</code>) to introduce the exponent. The exponent always contains two digits; if the value is zero, the exponent is 00.</li><li><code>fF</code> The double argument is rounded and converted to decimal notation in the format <code>"[-]ddd.ddd"</code>, where the number of digits after the decimal-point character is equal to the precision specification. If the precision is missing, it is taken as 6; if the precision is explicitly zero, no decimal-point character appears. If a decimal point appears, at least one digit appears before it.</li><li><code>gG</code> The double argument is converted in style <code>f</code> or <code>e</code> (or <code>F</code> or <code>E</code> for <code>G</code> conversions). The precision specifies the number of significant digits. If the precision is missing, 6 digits are given; if the precision is zero, it is treated as 1. Style <code>e</code> is used if the exponent from its conversion is less than -4 or greater than or equal to the precision. Trailing zeros are removed from the fractional part of the result; a decimal point appears only if it is followed by at least one digit.</li><li><code>S</code> Similar to the <code>s</code> format, except the pointer is expected to point to a program-memory (ROM) string instead of a RAM string.</li></ul>
<p>
In no case does a non-existent or small field width cause truncation of a numeric field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result.<p>
Since the full implementation of all the mentioned features becomes fairly large, three different flavours of <a class="el" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf()</a> can be selected using linker options. The default <a class="el" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf()</a> implements all the mentioned functionality except floating point conversions. A minimized version of <a class="el" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf()</a> is available that only implements the very basic integer and string conversion facilities, but only the <code>#</code> additional option can be specified using conversion flags (these flags are parsed correctly from the format specification, but then simply ignored). This version can be requested using the following <a class="el" href="using_tools.html#gcc_minusW">compiler options</a>:<p>
<div class="fragment"><pre class="fragment">   -Wl,-u,<a class="code" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf</a> -lprintf_min
</pre></div><p>
If the full functionality including the floating point conversions is required, the following options should be used:<p>
<div class="fragment"><pre class="fragment">   -Wl,-u,<a class="code" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf</a> -lprintf_flt -lm
</pre></div><p>
<dl class="user" compact><dt><b>Limitations:</b></dt><dd><ul>
<li>The specified width and precision can be at most 255.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Notes:</b></dt><dd><ul>
<li>For floating-point conversions, if you link default or minimized version of <a class="el" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf()</a>, the symbol <code></code>? will be output and double argument will be skiped. So you output below will not be crashed. For default version the width field and the "pad to left" ( symbol minus ) option will work in this case.</li><li>The <code>hh</code> length modifier is ignored (<code>char</code> argument is promouted to <code>int</code>). More exactly, this realization does not check the number of <code>h</code> symbols.</li><li>But the <code>ll</code> length modifier will to abort the output, as this realization does not operate <code>long</code> <code>long</code> arguments.</li><li>The variable width or precision field (an asterisk <code>*</code> symbol) is not realized and will to abort the output. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g55b25ecbfd3811ea4495d1f235e2e186"></a><!-- doxytag: member="stdio.h::vfprintf_P" ref="g55b25ecbfd3811ea4495d1f235e2e186" args="(FILE *__stream, const char *__fmt, va_list __ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfprintf_P           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>__ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <code><a class="el" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf()</a></code> that uses a <code>fmt</code> string that resides in program memory. 
</div>
</div><p>
<a class="anchor" name="g67bae1ad3af79809fd770be392f90e21"></a><!-- doxytag: member="stdio.h::vfscanf" ref="g67bae1ad3af79809fd770be392f90e21" args="(FILE *__stream, const char *__fmt, va_list __ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfscanf           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Formatted input. This function is the heart of the <b>scanf</b> family of functions.<p>
Characters are read from <em>stream</em> and processed in a way described by <em>fmt</em>. Conversion results will be assigned to the parameters passed via <em>ap</em>.<p>
The format string <em>fmt</em> is scanned for conversion specifications. Anything that doesn't comprise a conversion specification is taken as text that is matched literally against the input. White space in the format string will match any white space in the data (including none), all other characters match only itself. Processing is aborted as soon as the data and format string no longer match, or there is an error or end-of-file condition on <em>stream</em>.<p>
Most conversions skip leading white space before starting the actual conversion.<p>
Conversions are introduced with the character <b>%</b>. Possible options can follow the <b>%</b>:<p>
<ul>
<li>a <code>*</code> indicating that the conversion should be performed but the conversion result is to be discarded; no parameters will be processed from <code>ap</code>,</li><li>the character <code>h</code> indicating that the argument is a pointer to <code>short int</code> (rather than <code>int</code>),</li><li>the 2 characters <code>hh</code> indicating that the argument is a pointer to <code>char</code> (rather than <code>int</code>).</li><li>the character <code>l</code> indicating that the argument is a pointer to <code>long int</code> (rather than <code>int</code>, for integer type conversions), or a pointer to <code>double</code> (for floating point conversions),</li></ul>
<p>
In addition, a maximal field width may be specified as a nonzero positive decimal integer, which will restrict the conversion to at most this many characters from the input stream. This field width is limited to at most 255 characters which is also the default value (except for the <code>c</code> conversion that defaults to 1).<p>
The following conversion flags are supported:<p>
<ul>
<li><code>%</code> Matches a literal <code>%</code> character. This is not a conversion.</li><li><code>d</code> Matches an optionally signed decimal integer; the next pointer must be a pointer to <code>int</code>.</li><li><code>i</code> Matches an optionally signed integer; the next pointer must be a pointer to <code>int</code>. The integer is read in base 16 if it begins with <b>0x</b> or <b>0X</b>, in base 8 if it begins with <b>0</b>, and in base 10 otherwise. Only characters that correspond to the base are used.</li><li><code>o</code> Matches an octal integer; the next pointer must be a pointer to <code>unsigned int</code>.</li><li><code>u</code> Matches an optionally signed decimal integer; the next pointer must be a pointer to <code>unsigned int</code>.</li><li><code>x</code> Matches an optionally signed hexadecimal integer; the next pointer must be a pointer to <code>unsigned int</code>.</li><li><code>f</code> Matches an optionally signed floating-point number; the next pointer must be a pointer to <code>float</code>.</li><li><code>e, g, F, E, G</code> Equivalent to <code>f</code>.</li><li><code>s</code> Matches a sequence of non-white-space characters; the next pointer must be a pointer to <code>char</code>, and the array must be large enough to accept all the sequence and the terminating <code>NUL</code> character. The input string stops at white space or at the maximum field width, whichever occurs first.</li><li><code>c</code> Matches a sequence of width count characters (default 1); the next pointer must be a pointer to <code>char</code>, and there must be enough room for all the characters (no terminating <code>NUL</code> is added). The usual skip of leading white space is suppressed. To skip white space first, use an explicit space in the format.</li><li><code></code>[ Matches a nonempty sequence of characters from the specified set of accepted characters; the next pointer must be a pointer to <code>char</code>, and there must be enough room for all the characters in the string, plus a terminating <code>NUL</code> character. The usual skip of leading white space is suppressed. The string is to be made up of characters in (or not in) a particular set; the set is defined by the characters between the open bracket <code></code>[ character and a close bracket <code></code>] character. The set excludes those characters if the first character after the open bracket is a circumflex <code>^</code>. To include a close bracket in the set, make it the first character after the open bracket or the circumflex; any other position will end the set. The hyphen character <code>-</code> is also special; when placed between two other characters, it adds all intervening characters to the set. To include a hyphen, make it the last character before the final close bracket. For instance, <code>[^]0-9-]</code> means the set of <em>everything except close bracket, zero through nine, and hyphen</em>. The string ends with the appearance of a character not in the (or, with a circumflex, in) set or when the field width runs out. Note that usage of this conversion enlarges the stack expense.</li><li><code>p</code> Matches a pointer value (as printed by <code>p</code> in <a class="el" href="group__avr__stdio.html#g4c04da4953607fa5fa4d3908fecde449">printf()</a>); the next pointer must be a pointer to <code>void</code>.</li><li><code>n</code> Nothing is expected; instead, the number of characters consumed thus far from the input is stored through the next pointer, which must be a pointer to <code>int</code>. This is not a conversion, although it can be suppressed with the <code>*</code> flag.</li></ul>
<p>
These functions return the number of input items assigned, which can be fewer than provided for, or even zero, in the event of a matching failure. Zero indicates that, while there was input available, no conversions were assigned; typically this is due to an invalid input character, such as an alphabetic character for a <code>d</code> conversion. The value <code>EOF</code> is returned if an input failure occurs before any conversion such as an end-of-file occurs. If an error or end-of-file occurs after conversion has begun, the number of conversions which were successfully completed is returned.<p>
By default, all the conversions described above are available except the floating-point conversions and the width is limited to 255 characters. The float-point conversion will be available in the extended version provided by the library <code>libscanf_flt.a</code>. Also in this case the width is not limited (exactly, it is limited to 65535 characters). To link a program against the extended version, use the following compiler flags in the link stage:<p>
<div class="fragment"><pre class="fragment">     -Wl,-u,<a class="code" href="group__avr__stdio.html#g67bae1ad3af79809fd770be392f90e21">vfscanf</a> -lscanf_flt -lm
</pre></div><p>
A third version is available for environments that are tight on space. In addition to the restrictions of the standard one, this version implements no <code>%[</code> specification. This version is provided in the library <code>libscanf_min.a</code>, and can be requested using the following options in the link stage:<p>
<div class="fragment"><pre class="fragment">     -Wl,-u,<a class="code" href="group__avr__stdio.html#g67bae1ad3af79809fd770be392f90e21">vfscanf</a> -lscanf_min -lm
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g6c6b5b881ce8f4739777ff3a615e988a"></a><!-- doxytag: member="stdio.h::vfscanf_P" ref="g6c6b5b881ce8f4739777ff3a615e988a" args="(FILE *__stream, const char *__fmt, va_list __ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfscanf_P           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>__stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>__ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <a class="el" href="group__avr__stdio.html#g67bae1ad3af79809fd770be392f90e21">vfscanf()</a> using a <code>fmt</code> string in program memory. 
</div>
</div><p>
<a class="anchor" name="g0b15be24dd9db93355e1f62937fdfd9a"></a><!-- doxytag: member="stdio.h::vprintf" ref="g0b15be24dd9db93355e1f62937fdfd9a" args="(const char *__fmt, va_list __ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vprintf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>__ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function <code>vprintf</code> performs formatted output to stream <code>stdout</code>, taking a variable argument list as in <a class="el" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf()</a>.<p>
See <a class="el" href="group__avr__stdio.html#ga3b98c0d17b35642c0f3e4649092b9f1">vfprintf()</a> for details. 
</div>
</div><p>
<a class="anchor" name="g8bd4b760f67791a54e73111734caa82f"></a><!-- doxytag: member="stdio.h::vscanf" ref="g8bd4b760f67791a54e73111734caa82f" args="(const char *__fmt, va_list __ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vscanf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>__ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function <code>vscanf</code> performs formatted input from stream <code>stdin</code>, taking a variable argument list as in <a class="el" href="group__avr__stdio.html#g67bae1ad3af79809fd770be392f90e21">vfscanf()</a>.<p>
See <a class="el" href="group__avr__stdio.html#g67bae1ad3af79809fd770be392f90e21">vfscanf()</a> for details. 
</div>
</div><p>
<a class="anchor" name="gc92e8c42a044c8f50aad5c2c69e638e0"></a><!-- doxytag: member="stdio.h::vsnprintf" ref="gc92e8c42a044c8f50aad5c2c69e638e0" args="(char *__s, size_t __n, const char *__fmt, va_list ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vsnprintf           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>__s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <code><a class="el" href="group__avr__stdio.html#gaeb1bbe21a1b9b50b207ab059a67993f">vsprintf()</a></code>, but instead of assuming <code>s</code> to be of infinite size, no more than <code>n</code> characters (including the trailing NUL character) will be converted to <code>s</code>.<p>
Returns the number of characters that would have been written to <code>s</code> if there were enough space. 
</div>
</div><p>
<a class="anchor" name="g2071feb5c92bf50a6bd508a07ead9515"></a><!-- doxytag: member="stdio.h::vsnprintf_P" ref="g2071feb5c92bf50a6bd508a07ead9515" args="(char *__s, size_t __n, const char *__fmt, va_list ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vsnprintf_P           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>__s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <code><a class="el" href="group__avr__stdio.html#gc92e8c42a044c8f50aad5c2c69e638e0">vsnprintf()</a></code> that uses a <code>fmt</code> string that resides in program memory. 
</div>
</div><p>
<a class="anchor" name="gaeb1bbe21a1b9b50b207ab059a67993f"></a><!-- doxytag: member="stdio.h::vsprintf" ref="gaeb1bbe21a1b9b50b207ab059a67993f" args="(char *__s, const char *__fmt, va_list ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vsprintf           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>__s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Like <code><a class="el" href="group__avr__stdio.html#g6017094d9fd800fa02600d35399f2a2a">sprintf()</a></code> but takes a variable argument list for the arguments. 
</div>
</div><p>
<a class="anchor" name="gf47f5141509d1e434f9da2b27287a707"></a><!-- doxytag: member="stdio.h::vsprintf_P" ref="gf47f5141509d1e434f9da2b27287a707" args="(char *__s, const char *__fmt, va_list ap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vsprintf_P           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>__s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>__fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&nbsp;</td>
          <td class="paramname"> <em>ap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Variant of <code><a class="el" href="group__avr__stdio.html#gaeb1bbe21a1b9b50b207ab059a67993f">vsprintf()</a></code> that uses a <code>fmt</code> string that resides in program memory. 
</div>
</div><p>
</div>

<hr width="80%">
<p><center>Automatically generated by Doxygen 1.5.7 on 6 Nov 2008.</center></p>

</body>
</html>
